"""Classes to define Restaurant Info

Hierachy of Classes:
- Restaurant Info: Object
    - Unique Id: UUID
    - Restaurant Name: str
    - Coordinate: Object
    - Address: Object
    - Food Categories: Optional[Set[str]]
    - MenuURL: Optional[HttpUrl]
    - Services: List[str]
"""

from typing import Optional, Set
from uuid import UUID, uuid4
from copy import deepcopy
import json

from pydantic import BaseModel, Field, constr, HttpUrl, validator

from .utils    import to_lower_camel
from .location import Coordinate
from .services import Services


class Restaurant(BaseModel):
    """Class for full restaurant info with validation

    Attributes:
        id (UUID): Unique UUID generated by default
        name (str): Restaurant Name
        coordinate (Coordinate): Required coordinates
        address (str): Optional address for geolocating
        food_category (Set[FoodCategory]):
            A set of type of food, should be non-empty
        menu_url (HttpURL):
            A link to restaurant menu
        pickup_avaiable (bool): generated by services
        delivery_avaiable (bool): generated by services
        services (Services):
            A list of pickup and deliver services available
    """
    id: UUID = Field(default_factory=uuid4)
    name: str
    coordinate: Coordinate
    address: Optional[constr(min_length=1)]
    food_categories: Set[str] = set()
    menu_url: Optional[HttpUrl]
    pickup_available: bool = False
    delivery_available: bool = False
    services: Services = Services()

    class Config:
        """Config for Restaurant Model

        - Must comply as typical JS/JSON variable name
        """
        alias_generator = to_lower_camel

    @validator('services')
    def availability(cls, services, values):
        """Remap vales to actual services value for pickup + delivery
        """
        if services:
            values['pickup_available'] = services.pickup_available
            values['delivery_available'] = services.delivery_available
        return services

    def to_dynamo(self):
        """Export dict to be optimal for DynamoDB
        """
        ret = self.dict(by_alias=True, exclude_unset=True)
        coordinate = ret['coordinate']
        ret['latitude'] = coordinate['latitude']
        ret['longitude'] = coordinate['longitude']
        del ret['coordinate']
        ret['id'] = str(ret['id'])
        return ret

    @classmethod
    def from_dynamo(cls, restaurant):
        """Parse Dynamo dict to Restaurant model
        """
        data = deepcopy(restaurant)
        data['coordinate'] = {
            'latitude': data['latitude'],
            'longitude': data['longitude'],
        }
        return Restaurant(**data)
